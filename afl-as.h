#ifndef _HAVE_AFL_AS_H
#define _HAVE_AFL_AS_H

#include "config.h"
#include "types.h"

static const u8* trampoline_fmt_32=
    "\n"
    "/* --- TRAMPOLINE 32 --- */\n"
    ".align 4\n"
    "\n"
    "leal -16(%%esp), %%esp\n"
    "movl %%edi,  0(%%esp)\n"
    "movl %%edx,  4(%%esp)\n"
    "movl %%ecx,  8(%%esp)\n"
    "movl %%eax, 12(%%esp)\n"
    "movl $0x%08x, %%ecx\n"
    "call __afl_maybe_log\n"
    "movl 12(%%esp), %%eax\n"
    "movl  8(%%esp), %%ecx\n"
    "movl  4(%%esp), %%edx\n"
    "movl  0(%%esp), %%edi\n"
    "leal 16(%%esp), %%esp\n"
    "\n"
    "/* --- END --- */\n"
    "\n";
static const u8* trampoline_fmt_64=
    "\n"
    "/* --- TRAMPOLINE 64 --- */\n"
    ".align 4\n"
    "\n"
    "leaq -(128+24)(%%rsp), %%rsp\n"
    "movq %%rdx,  0(%%rsp)\n"
    "movq %%rcx,  8(%%rsp)\n"
    "movq %%rax, 16(%%rsp)\n"
    "movq $0x%08x, %%rcx\n"
    "call __afl_maybe_log\n"
    "movq 16(%%rsp), %%rax\n"
    "movq  8(%%rsp), %%rcx\n"
    "movq  0(%%rsp), %%rdx\n"
    "leaq (128+24)(%%rsp), %%rsp\n"
    "\n"
    "/* --- END --- */\n"
    "\n";
static const u8* main_payload_32 = 
    "\n"
    "/* --- MAIN PAYLOAD 32 --- */\n"
    "\n"
    ".text\n"
    ".att_syntax\n"
    ".code32\n"
    ".align 8\n"
    "\n"

    "__afl_maybe_log:\n"
    "\n"
    "  lahf\n"
    "  seto %al\n"
    "\n"
    "  /* Check if SHM region is already mapped. */\n"
    "\n"
    "  movl  __afl_area_ptr, %edx\n"
    "  testl %edx, %edx\n"
    "  je    __afl_setup\n"
    "\n"
    "__afl_store:\n"
    "\n"
    "  /* Calculate and store hit for the code location specified in ecx. There\n"
    "     is a double-XOR way of doing this without tainting another register,\n"
    "     and we use it on 64-bit systems; but it's slower for 32-bit ones. */\n"
    "\n"
    #ifndef COVERAGE_ONLY
    "  movl __afl_prev_loc, %edi\n"
    "  xorl %ecx, %edi\n"
    "  shrl $1, %ecx\n"
    "  movl %ecx, __afl_prev_loc\n"
    #else
    "  movl %ecx, %edi\n"
    #endif /* ^!COVERAGE_ONLY */
    "\n"
    #ifdef SKIP_COUNTS
    "  orb  $1, (%edx, %edi, 1)\n"
    #else
    "  incb (%edx, %edi, 1)\n"
    #endif /* ^SKIP_COUNTS */
    "\n"
    "__afl_return:\n"
    "\n"
    "  addb $127, %al\n"
    "  sahf\n"
    "  ret\n"
    "\n"
    ".align 8\n"
    "\n"
    "__afl_setup:\n"
    "\n"
    "  /* Do not retry setup if we had previous failures. */\n"
    "\n"
    "  cmpb $0, __afl_setup_failure\n"
    "  jne  __afl_return\n"
    "\n"
    "  /* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n"
    "     We do not save FPU/MMX/SSE registers here, but hopefully, nobody\n"
    "     will notice this early in the game. */\n"
    "\n"
    "  pushl %eax\n"
    "  pushl %ecx\n"
    "\n"
    "  pushl $.AFL_SHM_ENV\n"
    "  call  getenv\n"
    "  addl  $4, %esp\n"
    "\n"
    "  testl %eax, %eax\n"
    "  je    __afl_setup_abort\n"
    "\n"
    "  pushl %eax\n"
    "  call  atoi\n"
    "  addl  $4, %esp\n"
    "\n"
    "  pushl $0          /* shmat flags    */\n"
    "  pushl $0          /* requested addr */\n"
    "  pushl %eax        /* SHM ID         */\n"
    "  call  shmat\n"
    "  addl  $12, %esp\n"
    "\n"
    "  cmpl $-1, %eax\n"
    "  je   __afl_setup_abort\n"
    "\n"
    "  /* Store the address of the SHM region. */\n"
    "\n"
    "  movl %eax, __afl_area_ptr\n"
    "  movl %eax, %edx\n"
    "\n"
    "  popl %ecx\n"
    "  popl %eax\n"
    "\n"
    "__afl_forkserver:\n"
    "\n"
    "  /* Enter the fork server mode to avoid the overhead of execve() calls. */\n"
    "\n"
    "  pushl %eax\n"
    "  pushl %ecx\n"
    "  pushl %edx\n"
    "\n"
    "  /* Phone home and tell the parent that we're OK. (Note that signals with\n"
    "     no SA_RESTART will mess it up). If this fails, assume that the fd is\n"
    "     closed because we were execve()d from an instrumented binary, or because\n" 
    "     the parent doesn't want to use the fork server. */\n"
    "\n"
    "  pushl $4          /* length    */\n"
    "  pushl $__afl_temp /* data      */\n"
    "  pushl $" STRINGIFY((FORKSRV_FD + 1)) "  /* file desc */\n"
    "  call  write\n"
    "  addl  $12, %esp\n"
    "\n"
    "  cmpl  $4, %eax\n"
    "  jne   __afl_fork_resume\n"
    "\n"
    "__afl_fork_wait_loop:\n"
    "\n"
    "  /* Wait for parent by reading from the pipe. Abort if read fails. */\n"
    "\n"
    "  pushl $4          /* length    */\n"
    "  pushl $__afl_temp /* data      */\n"
    "  pushl $" STRINGIFY(FORKSRV_FD) "        /* file desc */\n"
    "  call  read\n"
    "  addl  $12, %esp\n"
    "\n"
    "  cmpl  $4, %eax\n"
    "  jne   __afl_die\n"
    "\n"
    "  /* Once woken up, create a clone of our process. This is an excellent use\n"
    "     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n"
    "     caches getpid() results and offers no way to update the value, breaking\n"
    "     abort(), raise(), and a bunch of other things :-( */\n"
    "\n"
    "  call fork\n"
    "\n"
    "  cmpl $0, %eax\n"
    "  jl   __afl_die\n"
    "  je   __afl_fork_resume\n"
    "\n"
    "  /* In parent process: write PID to pipe, then wait for child. */\n"
    "\n"
    "  movl  %eax, __afl_fork_pid\n"
    "\n"
    "  pushl $4              /* length    */\n"
    "  pushl $__afl_fork_pid /* data      */\n"
    "  pushl $" STRINGIFY((FORKSRV_FD + 1)) "      /* file desc */\n"
    "  call  write\n"
    "  addl  $12, %esp\n"
    "\n"
    "  pushl $0             /* no flags  */\n"
    "  pushl $__afl_temp    /* status    */\n"
    "  pushl __afl_fork_pid /* PID       */\n"
    "  call  waitpid\n"
    "  addl  $12, %esp\n"
    "\n"
    "  cmpl  $0, %eax\n"
    "  jle   __afl_die\n"
    "\n"
    "  /* Relay wait status to pipe, then loop back. */\n"
    "\n"
    "  pushl $4          /* length    */\n"
    "  pushl $__afl_temp /* data      */\n"
    "  pushl $" STRINGIFY((FORKSRV_FD + 1)) "  /* file desc */\n"
    "  call  write\n"
    "  addl  $12, %esp\n"
    "\n"
    "  jmp __afl_fork_wait_loop\n"
    "\n"
    "__afl_fork_resume:\n"
    "\n"
    "  /* In child process: close fds, resume execution. */\n"
    "\n"
    "  pushl $" STRINGIFY(FORKSRV_FD) "\n"
    "  call  close\n"
    "\n"
    "  pushl $" STRINGIFY((FORKSRV_FD + 1)) "\n"
    "  call  close\n"
    "\n"
    "  addl  $8, %esp\n"
    "\n"
    "  popl %edx\n"
    "  popl %ecx\n"
    "  popl %eax\n"
    "  jmp  __afl_store\n"
    "\n"
    "__afl_die:\n"
    "\n"
    "  xorl %eax, %eax\n"
    "  call _exit\n"
    "\n"
    "__afl_setup_abort:\n"
    "\n"
    "  /* Record setup failure so that we don't keep calling\n"
    "     shmget() / shmat() over and over again. */\n"
    "\n"
    "  incb __afl_setup_failure\n"
    "  popl %ecx\n"
    "  popl %eax\n"
    "  jmp __afl_return\n"
    "\n"
    ".AFL_VARS:\n"
    "\n"
    "  .comm   __afl_area_ptr, 4, 32\n"
    "  .comm   __afl_setup_failure, 1, 32\n"
    #ifndef COVERAGE_ONLY
    "  .comm   __afl_prev_loc, 4, 32\n"
    #endif /* !COVERAGE_ONLY */
    "  .comm   __afl_fork_pid, 4, 32\n"
    "  .comm   __afl_temp, 4, 32\n"
    "\n"
    ".AFL_SHM_ENV:\n"
    "  .asciz \"" SHM_ENV_VAR "\"\n"
    "\n"
    "/* --- END --- */\n"
    "\n";
#define CALL_L64(str)		"call " str "@PLT\n"
static const u8* main_payload_64 = 
    "\n"
    "/* --- MAIN PAYLOAD 64 --- */\n"
    "\n"
    ".text\n"
    ".att_syntax\n"
    ".code64\n"
    ".align 8\n"
    "\n"
    "__afl_maybe_log:\n"
    "\n"
    "  lahf\n"
    "  seto %al\n"
    "\n"
    "  /* check if shm is mapped */\n"
    "\n"
    "  movq __afl_area_ptr(%rip), %rdx\n"
    "  testq %rdx, %rdx\n"
    "  je  __afl_setup\n"
    "\n"
    "__afl_store:\n"
    "\n"
    "  /* calc and store hit in %rcx */\n"
    "\n"
#ifndef COVERAGE_ONLY
    "  xorq __afl_prev_loc(%rip), %rcx\n"
    "  xorq %rcx, __afl_prev_loc(%rip)\n"
    "  shrq $1, __afl_prev_loc(%rip)\n"
#endif
    "\n"
#ifdef SKIP_COUNTS
    "  orb $1, (%rdx, %rcx, 1)\n"
#else
    "  incb (%rdx, %rcx, 1)\n"
#endif
    "\n"
    "__afl_return:\n"
    "\n"
    "  addb $127, %al\n"
    "  sahf\n"
    "  ret\n"
    "\n"
    ".align 8\n"
    "\n"
    "__afl_setup:\n"
    "\n"
    "  /* do not retry if failed */\n"
    "\n"
    "  cmpb $0, __afl_setup_failure(%rip)\n"
    "  jne __afl_return\n"
    "\n"
    "  /* check out if we have a global pointer on file */\n"
    "  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n"
    "  movq (%rdx), %rdx\n"
    "  testq %rdx, %rdx\n"
    "  je __afl_setup_first\n"
    "\n"
    "  movq %rdx, __afl_area_ptr(%rip)\n"
    "  jmp __afl_store\n"
    "__afl_setup_first:\n"
    "\n"
    "  /* save register */\n"
    "\n"
    "  leaq -352(%rsp),%rsp\n"
    "\n"
    "  movq %rax,  0(%rsp)\n"
    "  movq %rcx,  8(%rsp)\n"
    "  movq %rdi,  16(%rsp)\n"
    "  movq %rsi,  32(%rsp)\n"
    "  movq %r8,   40(%rsp)\n"
    "  movq %r9,   48(%rsp)\n"
    "  movq %r10,  56(%rsp)\n"
    "  movq %r11,  64(%rsp)\n"
    "\n"
    "  movq %xmm0,  96(%rsp)\n"
    "  movq %xmm1,  112(%rsp)\n"
    "  movq %xmm2,  128(%rsp)\n"
    "  movq %xmm3,  144(%rsp)\n"
    "  movq %xmm4,  160(%rsp)\n"
    "  movq %xmm5,  176(%rsp)\n"
    "  movq %xmm6,  192(%rsp)\n"
    "  movq %xmm7,  208(%rsp)\n"
    "  movq %xmm8,  224(%rsp)\n"
    "  movq %xmm9,  240(%rsp)\n"
    "  movq %xmm10, 256(%rsp)\n"
    "  movq %xmm11, 272(%rsp)\n"
    "  movq %xmm12, 288(%rsp)\n"
    "  movq %xmm13, 304(%rsp)\n"
    "  movq %xmm14, 320(%rsp)\n"
    "  movq %xmm15, 336(%rsp)\n"
    "\n"
    "  /* map SHM, jump to __afl_setup_abort if wrong */\n"
    "\n"
    "  /* 16-byte stack alignment */\n"
    "  pushq %r12\n"
    "  movq %rsp, %r12\n"
    "  subq $16,%rsp\n"
    "  andq $0xfffffffffffffff0,%rsp\n"
    "\n"
    "  leaq .AFL_SHM_ENV(%rip), %rdi\n"
    CALL_L64("getenv")
    "\n"
    "  testq %rax, %rax\n"
    "  je __afl_setup_abort\n"
    "\n"
    "  movq %rax,%rdi\n"
    CALL_L64("atoi")
    "\n"
    "  xorq %rdx, %rdx   /* shmat flags    */\n"
    "  xorq %rsi, %rsi   /* requested addr */\n"
    "  movq %rax, %rdi   /* SHM ID         */\n"
    CALL_L64("shmat")
    "\n"
    "  cmpq $-1,%rax\n"
    "  je __afl_setup_abort\n"
    "\n"
    "  /* store addr of SHM */\n"
    "\n"
    "  movq %rax,%rdx\n"
    "  movq %rax,__afl_area_ptr(%rip)\n"
    "\n"
    "  movq __afl_global_area_ptr@GOTPCREL(%rip), %rdx\n"
    "  movq %rax,(%rdx)\n"
    "  movq %rax,%rdx\n"
    "\n"
    "__afl_forkserver:\n"
    "\n"
    "  /* keep stack alignment */\n"
    "\n"
    "  pushq %rdx\n"
    "  pushq %rdx\n"
    "\n"
    "  /* tell the parent that we're OK */\n"
    "\n"
    "  movq $4, %rdx                /* len */\n"
    "  leaq __afl_temp(%rip),%rsi    /* data */\n"
    "  movq $"STRINGIFY((FORKSRV_FD+1))",%rdi\n"
    CALL_L64("write")
    "\n"
    "  cmpq $4,%rax\n"
    "  jne __afl_fork_resume\n"
    "\n"
    "__afl_fork_wait_loop:\n"
    "\n"
    "  /* wait for parent by read */\n"
    "\n"
    "  movq $4, %rdx               /* length    */\n"
    "  leaq __afl_temp(%rip), %rsi /* data      */\n"
    "  movq $" STRINGIFY(FORKSRV_FD) ", %rdi\n"
    CALL_L64("read")
    "  cmpq $4, %rax\n"
    "  jne __afl_die\n"
    "\n"
    "  /* Once woken up, create a clone of our process */\n"
    "\n"
    CALL_L64("fork")
    "  cmpq $0,%rax\n"
    "  jl __afl_die\n"
    "  je __afl_fork_resume\n"
    "\n"
    "  /* parent process: write PID to pipe, then wait for child */\n"
    "\n"
    "  movl %eax, __afl_fork_pid(%rip)\n"
    "\n"
    "  movq $4,%rdx                     /* len */\n"
    "  leaq __afl_fork_pid(%rip), %rsi  /* data */\n"
    "  movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi\n"
    CALL_L64("write")
    "\n"
    "  movq $0, %rdx                   /* no flags  */\n"
    "  leaq __afl_temp(%rip), %rsi     /* status    */\n"
    "  movq __afl_fork_pid(%rip), %rdi /* PID       */\n"
    CALL_L64("waitpid")
    "  cmpq $0,%rax\n"
    "  jle __afl_die\n"
    "\n"
    "  /* relay status to pipe, loop back */\n"
    "\n"
    "  movq $4,%rdx\n"
    "  leaq __afl_temp(%rip),%rsi\n"
    "  movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi\n"     
    CALL_L64("write")
    "\n"
    "  jmp __afl_fork_wait_loop\n"
    "\n"
    "__afl_fork_resume:\n"
    "\n"
    "  /* child process: close fds, resume exec */\n"
    "\n"
    "  movq $" STRINGIFY(FORKSRV_FD) ", %rdi\n"
    CALL_L64("close")
    "  movq $" STRINGIFY((FORKSRV_FD + 1)) ", %rdi\n"
    CALL_L64("close")
    "\n"
    "  popq %rdx\n"
    "  popq %rdx\n"
    "\n"
    "  movq %r12, %rsp\n"
    "  popq %r12\n"
    "\n"
    "  movq  0(%rsp), %rax\n"
    "  movq  8(%rsp), %rcx\n"
    "  movq 16(%rsp), %rdi\n"
    "  movq 32(%rsp), %rsi\n"
    "  movq 40(%rsp), %r8\n"
    "  movq 48(%rsp), %r9\n"
    "  movq 56(%rsp), %r10\n"
    "  movq 64(%rsp), %r11\n"
    "\n"
    "  movq  96(%rsp), %xmm0\n"
    "  movq 112(%rsp), %xmm1\n"
    "  movq 128(%rsp), %xmm2\n"
    "  movq 144(%rsp), %xmm3\n"
    "  movq 160(%rsp), %xmm4\n"
    "  movq 176(%rsp), %xmm5\n"
    "  movq 192(%rsp), %xmm6\n"
    "  movq 208(%rsp), %xmm7\n"
    "  movq 224(%rsp), %xmm8\n"
    "  movq 240(%rsp), %xmm9\n"
    "  movq 256(%rsp), %xmm10\n"
    "  movq 272(%rsp), %xmm11\n"
    "  movq 288(%rsp), %xmm12\n"
    "  movq 304(%rsp), %xmm13\n"
    "  movq 320(%rsp), %xmm14\n"
    "  movq 336(%rsp), %xmm15\n"
    "\n"
    "  leaq 352(%rsp),%rsp\n"
    "\n"
    "  jmp __afl_store\n"
    "\n"
    "__afl_die:\n"
    "\n"
    "  xorq %rax, %rax\n"
    CALL_L64("_exit")
    "\n"
    "__afl_setup_abort:\n"
    "\n"
    "  /* record setup failure */\n"
    "\n"
    "  incb __afl_setup_failure(%rip)\n"
    "\n"
    "  movq %r12, %rsp\n"
    "  popq %r12\n"
    "\n"
    "  movq  0(%rsp), %rax\n"
    "  movq  8(%rsp), %rcx\n"
    "  movq 16(%rsp), %rdi\n"
    "  movq 32(%rsp), %rsi\n"
    "  movq 40(%rsp), %r8\n"
    "  movq 48(%rsp), %r9\n"
    "  movq 56(%rsp), %r10\n"
    "  movq 64(%rsp), %r11\n"
    "\n"
    "  movq  96(%rsp), %xmm0\n"
    "  movq 112(%rsp), %xmm1\n"
    "  movq 128(%rsp), %xmm2\n"
    "  movq 144(%rsp), %xmm3\n"
    "  movq 160(%rsp), %xmm4\n"
    "  movq 176(%rsp), %xmm5\n"
    "  movq 192(%rsp), %xmm6\n"
    "  movq 208(%rsp), %xmm7\n"
    "  movq 224(%rsp), %xmm8\n"
    "  movq 240(%rsp), %xmm9\n"
    "  movq 256(%rsp), %xmm10\n"
    "  movq 272(%rsp), %xmm11\n"
    "  movq 288(%rsp), %xmm12\n"
    "  movq 304(%rsp), %xmm13\n"
    "  movq 320(%rsp), %xmm14\n"
    "  movq 336(%rsp), %xmm15\n"
    "\n"
    "  leaq 352(%rsp), %rsp\n"
    "\n"
    "  jmp __afl_return\n"
    "\n"
    ".AFL_VARS:\n"
    "\n"
    "  .lcomm   __afl_area_ptr, 8\n"
    #ifndef COVERAGE_ONLY
    "  .lcomm   __afl_prev_loc, 8\n"
    #endif /* !COVERAGE_ONLY */
    "  .lcomm   __afl_fork_pid, 4\n"
    "  .lcomm   __afl_temp, 4\n"
    "  .lcomm   __afl_setup_failure, 1\n"
    "  .comm    __afl_global_area_ptr,8,8\n"
    "\n"
    ".AFL_SHM_ENV:\n"
    "  .asciz \""SHM_ENV_VAR"\"\n"
    "\n"
    "/* --- END --- */\n"
    "\n";

#endif